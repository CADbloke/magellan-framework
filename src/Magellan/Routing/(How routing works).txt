This page explains how routing works in general. It took a while to come up with this design, and I'll blog 
about it sometime. For now, here's the general idea:

Routes are registered in a RouteCollection. 

    var routes = new ControllerRouteCollection(controllerFactory);
    routes.Register("/patients/{action}").Defaults(controller => "Patients", action => "List");

Routes are used in two ways:

    1. We can resolve a path, such as "/patients/edit", to a Route. 
    2. We can resolve route data, such as controller => "Patients", action => "Edit", to a path

Routes implement the IRoute interface, but there is only one implementation by default - the Route class. 

The Route class defers to a couple of objects:

    - IRouteParser, which parses the "route specification" (e.g., "/patients/list")
    - IRouteValidator, which checks constraints on a route

Generally you shouldn't have to derive from Route - just passing implementations or route settings into the 
constructors ought to be enough. 

Route validation is fairly straightforward. The DefaultRouteValidator class just runs a series of checks on 
the route to ensure it's OK. It then returns a collection of issues with the route. Examples of validation
errors that might be reported include:

    - When part of the route specification uses invalid characters
    - When you have two or more "catch-all" wildcard segments
    - When catch-all wildcard segments appear anywhere except the end of the route specification
    - The same parameter name appears more than once in the route specification

Route validation is perfomed when a route is registered in a RouteCollection, this way the exception that is 
thrown appears when the application starts up at the appropriate registration line, rather than later. 

Route parsing is where most of the complexity is. The RouteParser is the object responsible for parsing a 
route. It generally works something like this:

   1. Take a route specification, like "/patients/{action}"
   2. Trim and tokenize the route specification, yielding an array of 'parts', such as: 
      ["patients", "{action}"]
   3. Iterate the parts. For each part, use a strategy pattern (ISegmentRecognizer) to create a Segment 
      object recognising the route. In this example:
        - The "patients" part will be matched by LiteralSegmentRecognizer, producing a LiteralSegment
        - The "{actions}" part will be matched by ParameterSegmentRecognizer, producing a ParameterSegment
      Each segment is populated with the data it will later need to match - e.g., the LiteralSegment will 
      store the constant "patients", and will check for that constant when comparing with a path.
   4. The array of Segments produced by step 3 will later be used to match the path

The RouteParser produces a ParsedRoute, which is then stored for the life of the route. It can quickly 
be used to take a path, like "patients/list", and see if it matches the route specification. Or it can 
help to build up a path given a set of route values from which to extract.

Three kinds of segments/segment recogniser are used:

  1. LiteralSegment/LiteralSegmentRecognizer: "foo"
  2. ParameterSegment/ParameterSegmentRecognizer: "{foo}"
  3. CatchAllParameterSegment/CatchAllParameterSegmentRecognizer: "{*foo}"

That's how routing works in a nutshell :)
